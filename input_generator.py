#!/usr/bin/env python


"""
Generate input data for MapReduce job for neuronal modeling.
The generated input file is a text file with each line represents a neuron.


The line is in the following format:
 ^neuron id; neuron type; number of iteration; a; b; c; d; membrane recovery variable (u); membrane potential (v);
 synaptic weight summation; synaptic connection weights (elements delimited by comma); fired or not (Y/N)$
"""


import numpy
import os
import shutil
#import matplotlib.pyplot as plt

DEBUG = False
#DEBUG = True

def generate_abcduv(Ne, Ni):
    """
    Generate parameters a, b, c and d.
    Generate intial values of v and u and S.
    v represents membrane potential of the neuron.
    u represents a membrane recovery variable which provide negative feedback to v.
    S is synaptic connection weight matrix.
    """
    re = numpy.random.rand(Ne)
    ri = numpy.random.rand(Ni)

    a_e = 0.02 * numpy.ones(Ne)
    a_i = 0.02 + 0.08*ri

    # a is an array with Ne+Ni elements
    a = numpy.concatenate((a_e, a_i))

    b_e = 0.2 * numpy.ones(Ne)
    b_i = 0.25 - 0.05*ri

    # b is an array with Ne+Ni elements
    b = numpy.concatenate((b_e, b_i))

    c_e = -65 + 15 * (re ** 2)
    c_i = -65 * numpy.ones(Ni)

    # c is an array with Ne+Ni elements
    c = numpy.concatenate((c_e, c_i))

    d_e = 8 - 6 * (re ** 2)
    d_i = 2 * numpy.ones(Ni)

    # d is an array with Ne+Ni elements
    d = numpy.concatenate((d_e, d_i))

    v = -65 * numpy.ones(Ne+Ni)
    u = b * v

    ## No need to generate the whole weight matrix in a whole.
    ## Matrix operation is time consuming, waste too much memeory buffer!

    # S_e = 0.5 * numpy.random.rand(Ne+Ni, Ne)
    # S_i = -1.0 * numpy.random.rand(Ne+Ni, Ni)
    ## In matrix S, we use column index to represents a neuron.
    ## So for jth column, the whole column represents the synaptic
    ## connection weights between the jth neuron and all the other neurons.
    # S = numpy.hstack((S_e, S_i))
    ## Transpose the matrix so that we can extract weights for each neuron row by row.
    # S = S.transpose()

    if DEBUG:
        print 'length of v:', len(v)
        print 'v =', v

        print 'length of u:', len(u)
        print 'u =', u

    return a, b, c, d, u, v

def plot_data(u, v, S):
    plt.clf()
    plt.plot(u)
    plt.savefig('u.png')
    plt.clf()
    plt.plot(v)
    plt.savefig('v.png')
    plt.clf()
    S = S.transpose()
    plt.plot(S)
    plt.savefig('S.png')
    plt.clf()
    plt.imshow(S)
    plt.show()

def get_weights(num_of_neurons, neuron_type):
    """Returns an array of synaptic weights given
    total number of neurons and type of neuron."""
    
    if neuron_type == 'e':
        return 0.5 * numpy.random.rand(num_of_neurons)
    if neuron_type == 'i':
        return -1 * numpy.random.rand(num_of_neurons)


def format_float(x):
    """Formats a float number 'x' with precision of 2
    and returns it as a string."""
    return '%.2f' % x

    
def main():
    Ne = 800 # Number of Excitatory neurons
    Ni = 200 # Number of Inhibitory neurons

    SUM = 0 # Initial summation of synaptic connection is 0.

    a, b, c, d, u, v = generate_abcduv(Ne, Ni)
    #plot_data(u,v,S)

    # Indicate this is input data generated by Python.
    input_dir = './input_by_py'
    if os.path.exists(input_dir):
        shutil.rmtree(input_dir)
        
    os.mkdir(input_dir)

    fname_neuron = os.path.join(input_dir, 'neurons.txt')
    fp_neuron = open(fname_neuron, 'w')
    fname_matrix = os.path.join(input_dir, 'weight_matrix.txt')
    fp_matrix = open(fname_matrix, 'w')
    neuron_type = ''
    for neuron_id in range(0, Ne+Ni):
        ## Neuron ID, starts from 1
        line = str(neuron_id+1) + ';'

        # Neuron type: excitatory
        if neuron_id < Ne:
            neuron_type = 'e' # Neuron type: excitatory
        else:
            neuron_type = 'i' # Neuron type: inhibitory

        line += neuron_type + ';'
        # Number of Iteration that has been done.
        line += '0' + ';'

        line += '%.2f' % a[neuron_id] + ';'
        line += '%.2f' % b[neuron_id] + ';'
        line += '%.2f' % c[neuron_id] + ';'
        line += '%.2f' % d[neuron_id] + ';'
        line += '%.2f' % u[neuron_id] + ';'
        line += '%.2f' % v[neuron_id] + ';'
        line += '0' + ';' # Initial summation of synaptic connection is 0
        line += 'N\n' # intitial, all neurons are not fired. 'Y' represents fired.

        fp_neuron.write(line)

        weights = map(format_float, get_weights(Ne+Ni, neuron_type))
        weights_line = ','.join(weights)
        weights_line += '\n'
        fp_matrix.write(weights_line)

    fp_neuron.close()
    fp_matrix.close()


if __name__ == '__main__':
    main()

